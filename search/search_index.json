{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django VectorDB","text":"<p>Django Vector DB is a powerful and flexible toolkit for adding vector similarity search to your Django applications. It is built on top of lightening fast approximate nearest neighbor search library: hnswlib.</p> <p>Some reasons you might want to use Django Vector DB:</p> <ul> <li>Low latency, because you don't need to call an external API.</li> <li>Scalable to a billion vectors with millisecond search results.</li> <li>Fast and accurate search.</li> <li>Native Django integration.</li> <li>Metadata filtering with the full power of the django queryset queries, e.g. <code>vectordb.filter(metadata__user_id=1).search(\"some text\").only(\"text\")</code></li> <li>Automatic syncing between your models and the vector index, simply register the provided signals and you can continue about your day. Vectordb will sync the vector database whenever you create, update or delete an instance.</li> <li>Out of the box support for incremental updates, allowing you to add or update data without rebuilding the entire index.</li> <li>Extensive documentation and support for easy implementation and troubleshooting.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Django VectorDB requires the following:</p> <ul> <li>Python (3.6, 3.7, 3.8, 3.9, 3.10, 3.11)</li> <li>Django (2.2, 3.0, 3.1, 3.2, 4.0, 4.1, 4.2)</li> <li>HNSWLib (0.7.0)</li> <li>numpy</li> </ul> <p>We highly recommend and only officially support the latest patch release of each Python and Django series.</p> <p>The following packages are optional:</p> <ul> <li>Sentence-Transformers - Add support for converting text into vector embeddings used for similarity search</li> <li>Django Rest Framework - Add API endpoint for VectorDB.</li> <li>django-filters - Add metadata filtering support on the API endpoint.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install using <code>pip</code>, it is recommended that you install the optional packages with:</p> <pre><code># This will install the optional dependencies above.\npip install \"django-vectordb[standard]\"\n</code></pre> <p>If you dont want to install the optional packages you can run:</p> <pre><code>pip install django-vectordb\n</code></pre> <p>Add <code>'django-vectordb'</code> to your <code>INSTALLED_APPS</code> setting.</p> settings.py<pre><code>INSTALLED_APPS = [\n...\n'vectordb',\n]\n</code></pre> <p>Run the migrations to create the <code>vectordb</code> table</p> <pre><code>$ ./manage.py migrate\n</code></pre> <p>If you're intending to use the API, you'll probably also want to add vectordb.urls. Add the following to your root <code>urls.py</code> file.</p> urls.py<pre><code>urlpatterns = [\n...\npath('api/', include('vectordb.urls'))\n]\n</code></pre> <p>Note: that the URL path can be whatever you want.</p> <p>This will expose endpoints for all CRUD actions (<code>/api/vectordb/</code>) and searching (<code>/api/vectordb/search/</code>).</p>"},{"location":"#example","title":"Example","text":"<p>Lets begin with a simple example for a blog post app. We will assume the app contains the following model in <code>blog/models.py</code>.</p> blog/models.py<pre><code>from django.db import models\nfrom django.contrib.auth import get_user_model\nUser = get_user_model()\nclass Post(models.Model):\ntitle = models.CharField(max_length=100)\ndescription = models.TextField()\nuser = models.ForeignKey(User, on_delete = models.CASCADE)\ndef __str__(self):\nreturn self.title\n</code></pre>"},{"location":"#1-working-with-the-django-vector-database","title":"1. Working with the Django Vector Database","text":"<p>To begin working with VectorDB, you'll first need to import it into your project. There are two ways to do this, depending on whether you'd like to use the simple proxy to the vector models manager, <code>Vector.objects</code>, or the Vector model directly.</p>"},{"location":"#option-1-import-the-simple-proxy-recommended","title":"Option 1: Import the simple proxy [Recommended]","text":"<pre><code>from vectordb import vectordb\n</code></pre>"},{"location":"#option-2-import-the-vector-model-directly","title":"Option 2: Import the Vector model directly","text":"<pre><code>from vectordb import get_vectordb_model\nVectorModel = get_vectordb_model()\n</code></pre> <p>With either of these imports, you'll have access to all the Django manager functions available on the object. Note that you can run the commands detailed below using <code>vectordb</code> or <code>VectorModel.objects</code>, whichever you've chosen to import. For the rest of this guide we will use <code>vectordb</code>.</p> <p>Now that you've imported VectorDB, it's time to dive in and explore its powerful features!</p>"},{"location":"#populating-the-vector-database","title":"Populating the Vector Database","text":"<p>First, let's make a few updates to the model to allow VectorDB to handle most tasks for us: add <code>get_vectordb_text</code> and <code>get_vectordb_metadata</code> methods.</p> blog/models.py<pre><code>from django.db import models\nfrom django.contrib.auth import get_user_model\nUser = get_user_model()\nclass Post(models.Model):\ntitle = models.CharField(max_length=100)\ndescription = models.TextField()\nuser = models.ForeignKey(User, on_delete=models.CASCADE)\ndef __str__(self):\nreturn self.title\ndef get_vectordb_text(self):\n# Use title and description for vector search\nreturn f\"{self.title} -- {self.description}\"\ndef get_vectordb_metadata(self):\n# Enable filtering by any of these metadata\nreturn {\"title\": self.title, \"description\": self.description, \"user_id\": self.user.id, \"model\": \"post\"}\n</code></pre> <p>In an existing project, you can run the <code>vectordb_sync</code> management command to add all items to the database.</p> <pre><code>./manage.py vectordb_sync &lt;app_name&gt; &lt;model_name&gt;\n</code></pre> <p>For this example:</p> <pre><code>./manage.py vectordb_sync blog Post\n</code></pre>"},{"location":"#automatically-incremental-updates","title":"Automatically Incremental Updates","text":"<p>Making sure that your vector database is up to date can be a pain. Django VectorDB makes this easy by laveraging django a signals that will automatically update the vector database whenever you create, update or delete an instance.</p> <p>To enable auto sync, register the model to vectordb sync handlers in <code>apps.py</code>. The sync handlers are signals defined in <code>vectordb/sync_signals.py</code>.</p> blog/apps.py<pre><code>from django.apps import AppConfig\nclass BlogConfig(AppConfig):\ndefault_auto_field = \"django.db.models.BigAutoField\"\nname = \"blog\"\ndef ready(self):\nfrom .models import Post\nfrom vectordb.shortcuts import autosync_model_to_vectordb\nautosync_model_to_vectordb(Post)\n</code></pre> <p>This will automatically sync the vectors when you create and delete instances.</p> <p>Note</p> <p>Note that signals are not called in bulk create, so you will need to sync manually when using those methods.</p> <p>Info</p> <p>While this example consider only one model class, you can register as many models are needed with django vector database. You can then utilize the versatile django filters to scope your searches. Note searching using a model instance automatically scopes the results to that instance type. See below for more details.</p> <p>Alternatively, you can import the following signals and register them by yourself:</p> blog/signals.py<pre><code># blog/signals.py\nfrom django.db.models.signals import post_save, post_delete\nfrom vectordb.sync_signals import (\nsync_vectordb_on_create_update,\nsync_vectordb_on_delete,\n)\nfrom .models import Post\npost_save.connect(\nsync_vectordb_on_create_update,\nsender=Post,\ndispatch_uid=\"update_vector_index_super_unique_id\",\n)\npost_delete.connect(\nsync_vectordb_on_delete,\nsender=Post,\ndispatch_uid=\"delete_vector_index_super_unique_id\",\n)\n</code></pre> <p>If you choose to manually register the signals you will need to make the following changes to the <code>apps.py</code>:</p> blog/apps.py<pre><code># blog/apps.py\nfrom django.apps import AppConfig\nclass BlogConfig(AppConfig):\ndefault_auto_field = \"django.db.models.BigAutoField\"\nname = \"blog\"\ndef ready(self):\nimport blog.signals\n</code></pre> <p>These signals will sync the vectors when you create and delete instances</p> <p>Ensure that your models implement the <code>get_vectordb_text()</code> and/or <code>get_vectordb_metadata()</code> methods for proper syncing.</p>"},{"location":"#manually-populating-the-django-vector-database","title":"Manually populating the django vector database","text":"<p>In some instances, you may want to manually populate the vector database. Django vector database provides two utility methods for adding items to the database: <code>vectordb.add_instance</code> or <code>vectordb.add_text</code>. Note that for adding the instance, you need to provide the <code>get_vectordb_text</code> and an optional <code>get_vectordb_metadata</code> methods.</p>"},{"location":"#1-adding-model-instances","title":"1. Adding Model Instances","text":"<pre><code>post1 = models.create(title=\"post1\", description=\"post1 description\", user=user1) # provide valid user\n# add to vector database\nvectordb.add_instance(post1)\n</code></pre>"},{"location":"#2-adding-text-to-the-model","title":"2. Adding Text to the Model","text":"<p>To add text to the database, you can use <code>vectordb.add_text()</code>:</p> <pre><code>vectordb.add_text(text=\"Hello text\", id=3, metadata={\"user_id\": 1})\n</code></pre> <p>The <code>text</code> and <code>id</code> are required. Additionally, the <code>id</code> must be unique, or an error will occur. <code>metadata</code> can be <code>None</code> or any valid JSON.</p>"},{"location":"#vector-similary-search-with-django-vector-database","title":"Vector Similary Search with Django Vector Database","text":"<p>To search, simply call <code>vectordb.search()</code>:</p> <pre><code>vectordb.search(\"Some text\", k=10) # k is the maximum number of results you want.\n</code></pre> <p>Note: search method returns a query whose results are order from best match. Each item will have the following fields: <code>id</code>, <code>content_object</code>, <code>object_id</code>, <code>content_type</code>, <code>text</code>, <code>embedding</code>, annotated <code>score</code>, and a property <code>vector</code> that returns the <code>np.ndarray</code> representation of the item. Because search gives us a <code>QuerySet</code> we can choose the fiels we want to see like sos:</p> <pre><code>vectordb.search(\"Some text\", k=10).only('text', 'content_object')\n</code></pre> <p>Search doesn't only work for <code>text</code> you can also search for model instances:</p> <pre><code>post1 = Post.objects.get(id=1)\n# Limit the search scope to a user with an id of 1\nresults = vectordb.search(post1, k=10)\n</code></pre> <p>This is also a way to get related posts to <code>post1</code>. Thus, you can use <code>vectordb</code> for recommendations as well.</p> <p>Note</p> <p>Using a model instance will automatically scope the results to only instances of that type. For example, if you search by <code>post1</code> you will only get results that are instances of <code>Post</code>.</p> <p>If <code>k</code> is not provided, the default value is 10.</p>"},{"location":"#metadata-filtering-with-django-vector-database","title":"Metadata Filtering with Django Vector Database","text":"<p>Django vector database provides a powerful way to filter on metadata, using the intuitive Django QuerySet methods.</p> <p>You can filter on <code>text</code> or <code>metadata</code> with the full power of Django QuerySet filtering. You can combine as many filters as needed. And since Django vector database is built on top of Django QuerySet, you can chain the filters with the search method. You can also filter on nested metadata fields.</p> <pre><code># scope the search to user with an id 1\nvectordb.filter(metadata__user_id=1).search(\"Some text\", k=10)\n# example two with more filters\nvectordb.filter(text__icontains=\"Apple\",\nmetadata__title__icontains=\"IPhone\",\nmetadata__description__icontains=\"2023\"\n).search(\"Apple new phone\", k=10)\n</code></pre> <p>If our metadata was nested like follows:</p> <pre><code>{\n\"text\": \"Sample text\",\n\"metadata\": {\n\"date\": {\n\"year\": 2021,\n\"month\": 7,\n\"day\": 20,\n\"time\": {\n\"hh\": 14,\n\"mm\": 30,\n\"ss\": 45\n}\n}\n}\n}\n</code></pre> <p>We can filter on the nested fields like so:</p> <pre><code>vectordb.filter(\nmetadata__date__year=2021,\nmetadata__date__time__hh=14\n).search(\"Sample text\", k=10)\n</code></pre> <p>Refer to the Django documentation on querying the <code>JSONField</code> for more information on filtering.</p>"},{"location":"#settings","title":"Settings","text":"<p>You can customize <code>vectordb</code> by overriding one of the following settings in <code>settings.py</code> file of your project. The following settings are available:</p> settings.py<pre><code># settings.py\nDJANGO_VECTOR_DB = {\n\"DEFAULT_EMBEDDING_CLASS\": \"vectordb.embedding_functions.SentenceTransformerEncoder\",\n\"DEFAULT_EMBEDDING_MODEL\": \"all-MiniLM-L6-v2\",\n# Can be \"cosine\" or \"l2\"\n\"DEFAULT_EMBEDDING_SPACE\": \"l2\"\n\"DEFAULT_EMBEDDING_DIMENSION\": 384, # Default is 384 for \"all-MiniLM-L6-v2\"\n\"DEFAULT_MAX_N_RESULTS\": 10, # Number of results to return from search maximum is default is 10\n\"DEFAULT_MIN_SCORE\": 0.0, # Minimum score to return from search default is 0.0\n\"DEFAULT_MAX_BRUTEFORCE_N\": 10_000, # Maximum number of items to search using brute force default is 10_000. If the number of items is greater than this number, the search will be done using the HNSW index.\n}\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Can't wait to get started? The quickstart guide is the fastest way to get up and running, and building APIs with REST framework.</p>"},{"location":"#development","title":"Development","text":"<p>Clone the repository</p> <pre><code>$ git clone https://github.com/pkavumba/django-vectordb.git\n</code></pre> <p>Install the app in editable mode with all dev dependencies:</p> <pre><code>pip install -e .[dev]\n</code></pre> <p>This command will install the app and its dev dependencies specified in the <code>setup.cfg</code> file. The <code>-e</code> flag installs the package in editable mode, which means that any changes you make to the app's source code will be reflected immediately without needing to reinstall the package. The <code>[dev]</code> part tells <code>pip</code> to install the dependencies listed under the \"dev\" section in the <code>options.extras_require</code> of the <code>setup.cfg</code> file.</p> <p>Run tests</p> <pre><code>pytest\n</code></pre> <p>Or</p> <pre><code>tox\n</code></pre>"},{"location":"tutorial/1-project-setup/","title":"Tutorial 1: Project Setup","text":"<p>Welcome to this tutorial on <code>django-vectordb</code>! Our goal is to learn how to use <code>vectordb</code>. To make it more relatable, we'll demonstrate the features of <code>django-vectordb</code> by building a basic blogging site.</p> <p>In this first lesson, we'll lay the groundwork for our blogging site by creating a model to store blog posts and developing basic views for creating, viewing, and examining the details of each post. This is the most work we have to do. Integrating <code>django-vectordb</code> is very easy and straight forward.</p> <p>As we delve deeper, we will explore the capabilities of <code>django-vectordb</code> by integrating related blog suggestions on the details page, based on vector similarity searches. This will showcase the flexibility and easy of use and power of <code>django-vectordb</code>.</p> <p>In the later stages of our tutorial, we will add a search page to demonstrate the text search features. Finally, we'll configure a REST API endpoint that allows for efficient AJAX searching and remote hosting of vectordb.</p> <p>Now, with the introduction out of the way, let's get coding started!</p>"},{"location":"tutorial/1-project-setup/#project-setup","title":"Project setup","text":"<p>Create a new Django project named <code>tutorial</code>, then start a new app called <code>blog</code>.</p> <pre><code># Create a virtual environment to isolate our package dependencies locally\npython3 -m venv env\nsource env/bin/activate  # On Windows use `env\\Scripts\\activate`\n# Install Django and VectorDB into the virtual environment\npip install django\npip install django-vectordb[standard] # include optional dependencies\n# Set up a new project with a single application\ndjango-admin startproject tutorial\ncd tutorial\ndjango-admin startapp blog\n</code></pre> <p>The project layout should look like:</p> <pre><code>    tutorial\n    \u251c\u2500\u2500 blog\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 admin.py\n    \u2502   \u251c\u2500\u2500 apps.py\n    \u2502   \u251c\u2500\u2500 migrations\n    \u2502   \u2502   \u2514\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 tests.py\n    \u2502   \u2514\u2500\u2500 views.py\n    \u251c\u2500\u2500 manage.py\n    \u2514\u2500\u2500 tutorial\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 asgi.py\n        \u251c\u2500\u2500 settings.py\n        \u251c\u2500\u2500 urls.py\n        \u2514\u2500\u2500 wsgi.py\n</code></pre> <p>Now lets add blog to the <code>INSTALLED_APPS</code> in <code>tutorial/settings.py</code></p> tutorial/settings.py<pre><code># settings.py\nINSTALLED_APPS = [\n\"django.contrib.admin\",\n\"django.contrib.auth\",\n\"django.contrib.contenttypes\",\n\"django.contrib.sessions\",\n\"django.contrib.messages\",\n\"django.contrib.staticfiles\",\n\"blog\", # &lt;--\n]\n</code></pre> <p>Next lets add a <code>POST</code> model to blog app <code>blog/models.py</code> for saving our posts</p> blog/models.py<pre><code># blog/models.py\nfrom django.db import models\nfrom django.contrib.auth import get_user_model\nUser = get_user_model()\nclass Post(models.Model):\ntitle = models.CharField(max_length=100)\ndescription = models.TextField()\nuser = models.ForeignKey(User, on_delete=models.CASCADE)\ncreated_at = models.DateTimeField(auto_now_add=True)\ndef __str__(self):\nreturn self.title\n</code></pre> <p>Our model has three fields, the <code>title</code>, <code>description</code>, <code>created_at</code>, and a <code>user</code> foreign key.</p> <p>Now sync your database for the first time:</p> <pre><code>python manage.py makemigrations # create migrations for blog\npython manage.py migrate\n</code></pre> <p>We'll also create an initial user named <code>admin</code> with a password. We'll authenticate as that user later in our example.</p> <pre><code>python manage.py createsuperuser --username admin --email admin@example.com\n</code></pre> <p>Once you've set up a database and the initial user is created and ready to go.</p> <p>Run the development server now</p> <pre><code>./manage.py runserver\n</code></pre>"},{"location":"tutorial/1-project-setup/#adding-sample-blogs","title":"Adding Sample Blogs","text":"<p>Lets add the Post model to the admins panel. Edit the <code>blog/admin.py</code></p> blog/admin.py<pre><code># blog/admin.py\nfrom django.contrib import admin\nfrom .models import Post\nadmin.site.register(Post)\n</code></pre> <p>Now we can visit <code>http://127.0.0.1:8000/admin/blog/post/</code> and add a few Posts. Go ahead and add something</p>"},{"location":"tutorial/1-project-setup/#forms","title":"Forms","text":"<p>In the last section we used the admin panel to add some post. Now lets add a form for post to the blogs.</p> <p>Create a new file in blog directory called <code>forms.py</code></p> blog/forms.py<pre><code># blog/forms.py\nfrom django import forms\nfrom .models import Post\nclass PostForm(forms.ModelForm):\nclass Meta:\nmodel = Post\nfields = [\"title\", \"description\"]\n</code></pre>"},{"location":"tutorial/1-project-setup/#views","title":"Views","text":"<p>Lets add some views for viewing our blog posts. We will keep things simple and use function based views.</p> <p>First create a directory called <code>templates</code> withing the blog app. Inside the <code>templates</code> directory create another folder called <code>blog</code>.</p> <p>Lets add a basic <code>base.html</code></p> blog/templates/blog/base.html<pre><code>&lt;!--blog/templates/blog/base.html--&gt;\n{% load static %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\" dir=\"ltr\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\" /&gt;\n&lt;title&gt;Django Vector Database&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"container\"&gt;{% block content %} {% endblock %}&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now lets create the list, detail, create view.</p> blog/views.py<pre><code>from django.shortcuts import render\nfrom django.contrib.auth.decorators import login_required\nfrom django.shortcuts import render, redirect, get_object_or_404\nfrom .models import Post\nfrom .forms import PostForm\ndef post_list(request):\nposts = Post.objects.all().order_by(\"-created_at\")\nreturn render(request, \"blog/post_list.html\", {\"posts\": posts})\ndef post_detail(request, pk):\npost = get_object_or_404(Post, pk=pk)\nreturn render(request, \"blog/post_detail.html\", {\"post\": post})\n@login_required\ndef post_create(request):\nif request.method == \"POST\":\nform = PostForm(request.POST)\nif form.is_valid():\npost = form.save(commit=False)\npost.user = request.user\npost.save()\nreturn redirect(\"post_list\")\nelse:\nform = PostForm()\nreturn render(request, \"blog/post_create.html\", {\"form\": form})\n</code></pre> <p>And finally, lets add the templates for these views.</p> <p>We will begin with a template that displays a list of blog posts with their titles as clickable links. The template extends the \"blog/base.html\" template. In case there are no posts, it displays the message \"No posts available.\" At the end, we add a link to create a new blog post using the \"post_create\" URL pattern.</p> blog/templates/blog/post_list.html<pre><code>&lt;!-- blog/templates/blog/post_list.html --&gt;\n{% extends \"blog/base.html\" %}\n{% block content %}\n&lt;h1&gt;Blog Posts&lt;/h1&gt;\n&lt;ul&gt;\n{% for post in posts %}\n&lt;li&gt;\n&lt;a href=\"{% url 'post_detail' post.pk %}\"&gt;{{ post.title }}&lt;/a&gt;\n&lt;/li&gt;\n{% empty %}\n&lt;li&gt;No posts available.&lt;/li&gt;\n{% endfor %}\n&lt;/ul&gt;\n&lt;a href=\"{% url 'post_create' %}\"&gt;Add New Post&lt;/a&gt;\n{% endblock %}\n</code></pre> <p>Next we add the template \"post_detail.html\" responsible for displaying the details of a single blog post. The template also includes a link to navigate back to the list of all blog posts.</p> blog/templates/blog/post_detail.html<pre><code>&lt;!-- blog/templates/blog/post_detail.html --&gt;\n{% extends \"blog/base.html\" %}\n{% block content %}\n&lt;h1&gt;{{ post.title }}&lt;/h1&gt;\n&lt;p&gt;{{ post.description }}&lt;/p&gt;\n&lt;a href=\"{% url 'post_list' %}\"&gt;Back to Posts List&lt;/a&gt;\n{% endblock %}\n</code></pre> blog/templates/blog/post_create.html<pre><code>&lt;!-- blog/templates/blog/post_create.html --&gt;\n{% extends \"blog/base.html\" %}\n{% block content %}\n&lt;h1&gt;Create New Post&lt;/h1&gt;\n&lt;form method=\"post\"&gt;\n{% csrf_token %} {{ form.as_p }}\n&lt;button type=\"submit\"&gt;Save Post&lt;/button&gt;\n&lt;/form&gt;\n&lt;a href=\"{% url 'post_list' %}\"&gt;Back to Posts List&lt;/a&gt;\n{% endblock %}\n</code></pre> <p>That covers the basic functionality we want to work with. However, there's still one more aspect to address. We need to ensure that users are associated with their respective blogs, which means providing a way for them to log in to the app for the post functionality to work correctly. As evident from the code, posting requires user authentication.</p> <p>So lets create a quick login form in <code>blog/templates/blog/login.html</code></p> blog/templates/blog/login.html<pre><code>&lt;!-- blog/templates/blog/login.html --&gt;\n{% extends 'blog/base.html' %}\n{% block content %}\n&lt;h2&gt;Login&lt;/h2&gt;\n&lt;form method=\"post\"&gt;\n{% csrf_token %} {{ form.as_p }}\n&lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n&lt;/form&gt;\n{% endblock %}\n</code></pre>"},{"location":"tutorial/1-project-setup/#urls","title":"URLs","text":"<p>Lets now add the urls for our views. Create a new file called <code>urls.py</code> in the blog app.</p> blog/urls.py<pre><code>from django.urls import path\n# import login view\nfrom django.contrib.auth.views import LoginView\nfrom . import views\nurlpatterns = [\npath(\"\", views.post_list, name=\"post_list\"),\npath(\"blogs/&lt;int:pk&gt;/\", views.post_detail, name=\"post_detail\"),\npath(\"blogs/create/\", views.post_create, name=\"post_create\"),\npath(\n\"accounts/login/\",\nLoginView.as_view(template_name=\"blog/login.html\"), # attach a template here\nname=\"login\",\n),\n]\n</code></pre> <p>This wraps up the boilerplate necessary for testing the Django vector database. Now when we run the server</p> <pre><code>./manage.py runserver\n</code></pre> <p>And we can view the details of the post by clicking the title.</p>"},{"location":"tutorial/1-project-setup/#summary","title":"Summary","text":"<p>In this tutorial we create a basic project to work with Django Vector Database. We created all the basic views and forms we need to create and view posts. Next lets integrated django vector database</p>"},{"location":"tutorial/2-adding-vector-search/","title":"Tutorial 2: Integrating Django Vector Database","text":"<p>Welcome to Tutorial 2! In the previous tutorial, we setup our Blog Post project that we will use for the rest of the tutorial to demonstrate the feature of <code>django-vectordb</code>. In this tutorial, we will integrate <code>django-vectordb</code> into our Blog Site. By the end of this tutorial, we will:</p> <ul> <li>Integrate <code>django-vectordb</code> into our project.</li> <li>Update our Post model to allow <code>django-vectordb</code> to automatically extract the text for vector search, as well as any metadata we want to filter on.</li> <li>Update the vector database with all the blog Posts that are currently on our site.</li> <li>Configure our site to automatically sync with the vector database whenever we <code>create</code>, <code>update</code> or <code>delete</code> posts.</li> <li>Configure our site to display related blog recommendations using the <code>django-vectordb</code>.</li> </ul> <p>Let's get started!</p>"},{"location":"tutorial/2-adding-vector-search/#adding-vectordb-to-the-project","title":"Adding VectorDB to the Project","text":"<p>If you haven't installed vectordb already, install it with the following command:</p> <pre><code>pip install \"django-vectordb[standard]\"\n</code></pre> <p>Next lets add <code>django-vectordb</code> to the <code>INSTALLED_APPS</code>. Open <code>tutorial/settings.py</code> and add <code>vectordb</code> to the installed apps.</p> tutorial/settings.py<pre><code># settings.py\nINSTALLED_APPS = [\n\"django.contrib.admin\",\n\"django.contrib.auth\",\n\"django.contrib.contenttypes\",\n\"django.contrib.sessions\",\n\"django.contrib.messages\",\n\"django.contrib.staticfiles\",\n\"blog\",\n\"vectordb\", # &lt;--\n]\n</code></pre> <p>Finally, lets run the migrations to create the <code>vectordb</code> table.</p> <pre><code>./manage.py migrate\n</code></pre>"},{"location":"tutorial/2-adding-vector-search/#update-post-model-for-vectordb-to-automatically-extract-text-and-metadata","title":"Update Post Model for VectorDB to Automatically Extract Text and Metadata","text":"<p>Next lets add to methods to our model to allow vectordb to properly index our Posts.</p> <p>First we need to pick the text we want to search by. For this tutorial we use both the <code>title</code> and the <code>description</code> of each blog. We tell <code>vectordb</code> about the text we want to use through the <code>get_vectordb_text</code> method. Second, we need to select the metadata we want to use for filtering. For this example, we will use the <code>user_id</code>, <code>username</code> and <code>created_at</code> of each blog post. We will break down the <code>create_at</code> into <code>year</code>, <code>month</code> and <code>day</code> to demonstrate nested filtering. We tell <code>django-vectordb</code> about the metadata we want to use through the <code>get_vectordb_metadata</code> method. If we don,t provide this method, vectordb will use the django serializer to serialize the entire model. This maybe suboptimal for large models.</p> blog/models.py<pre><code># blog/models.py\nfrom django.db import models\nfrom django.contrib.auth import get_user_model\nUser = get_user_model()\nclass Post(models.Model):\ntitle = models.CharField(max_length=100)\ndescription = models.TextField()\nuser = models.ForeignKey(User, on_delete=models.CASCADE)\ncreated_at = models.DateTimeField(auto_now_add=True)\ndef get_vectordb_text(self):\nreturn self.title + \" \" + self.description\ndef get_vectordb_metadata(self):\nreturn {\n\"user_id\": self.user.id,\n\"username\": self.user.username,\n\"created_at\": {\n\"year\": self.created_at.year,\n\"month\": self.created_at.month,\n\"day\": self.created_at.day,\n},\n}\n</code></pre>"},{"location":"tutorial/2-adding-vector-search/#update-vectordb-with-existing-posts","title":"Update VectorDB with Existing Posts","text":"<p>Django vector database provides a management command to update the vector database with existing models. It takes two arguments the <code>app_name</code> and the <code>model_name</code>, which in this case are <code>blog</code> and <code>Post</code>. Lets run this command to update the vector database with all the existing posts.</p> <pre><code>./manage.py vectordb_sync &lt;app_name&gt; &lt;model_name&gt;\n</code></pre> <pre><code>./manage.py vectordb_sync blog Post\n</code></pre> <p>Info</p> <p>Django vector database also provides a management command for reseting the vector database. Note that this is distractive and irreversible.</p> <pre><code>./manage.py vectordb_reset\n</code></pre>"},{"location":"tutorial/2-adding-vector-search/#summary","title":"Summary","text":"<p>In this tutorial, we successfully integrated the Django vector database into our blog post project. Additionally, we synced our existing blog posts with the Django vector database using the <code>vectordb_sync</code> management command. In the upcoming tutorial, we will set up our blog post app to automatically synchronize with the Django vector database whenever we <code>create</code>, <code>update</code>, or <code>delete</code> blog posts.</p>"},{"location":"tutorial/3-automatically-updating-vector-database/","title":"Tutorial 3: Setting Up Django Vector Database to Automatically Sync with Our Models","text":"<p>Welcome to Tutorial 3! In the previous tutorial, we added <code>django-vectordb</code> to our Blog Post project. We also saw how to add existing instance to django vector database using management commands. In this tutorial, we will set up our site to automatically sync with the vector database whenever we <code>create</code>, <code>update</code>, or <code>delete</code> post instances.</p> <p>Let's get started!</p>"},{"location":"tutorial/3-automatically-updating-vector-database/#configure-django-vector-database-to-automatically-sync-with-our-models","title":"Configure Django Vector Database to Automatically Sync with our Models","text":"<p>One of the common pain points while using vector databases is the process of keeping them in sync with our application's data. Synchronizing data can be time-consuming and prone to errors, making it a hassle for developers to manage different data sources effectively.</p> <p>Django Vector Database provides an effortless solution for this issue by enabling automatic synchronization with our models. By configuring the Django Vector Database AutoSync feature, you can ensure that our site stays in sync with the vector database every time you <code>create</code>, <code>update</code>, or <code>delete</code> posts.</p> <p>To achieve this seamless integration, you can use the Django Vector Database a convenient shortcut, <code>autosync_model_to_vectordb</code>, which allows you to register our models <code>post_save</code> and <code>post_delete</code> signals with django vector database. This shortcut register signals that will automatically sync our models with the vector database whenever you <code>create</code>, <code>update</code>, or <code>delete</code> instances.</p> blog/apps.py<pre><code>from django.apps import AppConfig\nclass BlogConfig(AppConfig):\ndefault_auto_field = \"django.db.models.BigAutoField\"\nname = \"blog\"\ndef ready(self):\nfrom vectordb.shortcuts import autosync_model_to_vectordb\nfrom .models import Post\nautosync_model_to_vectordb(Post)\n</code></pre> <p>Info</p> <p>Although this example focuses on a single model (<code>Post</code>), you can incorporate as many models as desired into the Django vector database.</p> <p>Note</p> <p>The automatic synchronization relies on the <code>post_save</code> and <code>post_delete</code> signals. As such, synchronization will not occur when using <code>bulk_create</code> since it does not trigger the <code>post_save</code> signal. If you need to sync after employing <code>bulk_create</code>, you must manually add the instances to the Django vector database. For more information, consult the [django-bulk-create] documentation.</p> <p>If you prefer, you can manually register the signals by importing the following signal handlers and registering them with our models' <code>post_save</code> and <code>post_delete</code> signals:</p> blog/signals.py<pre><code># blog/signals.py\nfrom django.db.models.signals import post_save, post_delete\nfrom vectordb.sync_signals import (\nsync_vectordb_on_create_update,\nsync_vectordb_on_delete,\n)\nfrom .models import Post\npost_save.connect(\nsync_vectordb_on_create_update,\nsender=Post,\ndispatch_uid=\"update_vector_index_super_unique_id\",\n)\npost_delete.connect(\nsync_vectordb_on_delete,\nsender=Post,\ndispatch_uid=\"delete_vector_index_super_unique_id\",\n)\n</code></pre> <p>If you choose to manually register the signals you will need to make the following changes to the <code>apps.py</code>:</p> blog/apps.py<pre><code># blog/apps.py\nfrom django.apps import AppConfig\nclass BlogConfig(AppConfig):\ndefault_auto_field = \"django.db.models.BigAutoField\"\nname = \"blog\"\ndef ready(self):\nimport blog.signals\n</code></pre>"},{"location":"tutorial/3-automatically-updating-vector-database/#summary","title":"Summary","text":"<p>In this tutorial, we learned how to configure Django Vector Database to automatically sync with our models. We also learned how to use the <code>autosync_model_to_vectordb</code> shortcut to register our models' <code>post_save</code> and <code>post_delete</code> signals with the Django Vector Database. In the upcoming tutorial, we will look at how to manually add data to the django vector database.</p>"},{"location":"tutorial/4-manually-updating-vector-database/","title":"Tutorial 4: Manually Updating the Django Vector Database","text":"<p>Introduction: In our previous tutorial, we explored how to automatically update the vector database. In this tutorial, we will learn how to manually update the vector database. This can be particularly useful when you want to add items to the database.</p> <p>VectorDB offers two utility methods for adding items to the database: <code>vectordb.add_instance</code> and <code>vectordb.add_text</code>. It is important to note that when adding an instance, you need to provide the <code>get_vectordb_text</code> method and an optional <code>get_vectordb_metadata</code> method.</p>"},{"location":"tutorial/4-manually-updating-vector-database/#adding-model-instances","title":"Adding Model Instances","text":"<p>To manually add a django model instance to the vector database, you can use the following code:</p> <pre><code>post1 = models.create(title=\"post1\", description=\"post1 description\", user=user1) # provide a valid user\n# Add the instance to the vector database\nvectordb.add_instance(post1)\n</code></pre>"},{"location":"tutorial/4-manually-updating-vector-database/#adding-text-to-the-model","title":"Adding Text to the Model","text":"<p>If you want to add text to the database, you can use the <code>vectordb.add_text()</code> method:</p> <pre><code>vectordb.add_text(text=\"Hello text\", id=3, metadata={\"user_id\": 1})\n</code></pre> <p>Both the <code>text</code> and <code>id</code> parameters are required when using this method. Additionally, the <code>id</code> must be unique; otherwise, an error will occur. The <code>metadata</code> parameter can be set to <code>None</code> or any valid JSON.</p> <p>By following these steps, you can manually update the Django vector database with new instances and text. This flexibility allows you to have more control over the data in our database and ensures that you can add items that may not be automatically included.</p>"},{"location":"tutorial/4-manually-updating-vector-database/#summary","title":"Summary","text":"<p>In this tutorial, we learned how to manually update the Django vector database by adding model instances and text. We explored the utility methods <code>vectordb.add_instance</code> and <code>vectordb.add_text</code>, which allow for greater control over the data in the database. This flexibility is particularly useful when you want to add items that may not be automatically included in the database.</p> <p>In the next tutorial, we will dive into performing vector similarity searches using the Django vector database. This powerful feature will enable you to find similar items in our database based on their vector representations, further enhancing the capabilities of our Django application. Stay tuned!</p>"},{"location":"tutorial/5-vector-search/","title":"5 - Vector Searching","text":""},{"location":"tutorial/5-vector-search/#coming-soon","title":"Coming Soon","text":""},{"location":"tutorial/6-adding-api-endpoint/","title":"6 - Adding a Vector Search Endpoint","text":""},{"location":"tutorial/6-adding-api-endpoint/#coming-soon","title":"Coming soon","text":""},{"location":"tutorial/quickstart/","title":"Quickstart","text":"<p>We're going to create a blogging site then add vector search to it through <code>django-vectordb</code>.</p>"},{"location":"tutorial/quickstart/#project-setup","title":"Project setup","text":"<p>Create a new Django project named <code>tutorial</code>, then start a new app called <code>blog</code>.</p> <pre><code># Create a virtual environment to isolate our package dependencies locally\npython3 -m venv env\nsource env/bin/activate  # On Windows use `env\\Scripts\\activate`\n# Install Django and Django VectorDB into the virtual environment\npip install django\npip install django-vectordb[standard] # include optional dependencies\n# Set up a new project with a single application\ndjango-admin startproject tutorial\ncd tutorial\ndjango-admin startapp blog\n</code></pre> <p>The project layout should look like:</p> <pre><code>    tutorial\n    \u251c\u2500\u2500 blog\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 admin.py\n    \u2502   \u251c\u2500\u2500 apps.py\n    \u2502   \u251c\u2500\u2500 migrations\n    \u2502   \u2502   \u2514\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 tests.py\n    \u2502   \u2514\u2500\u2500 views.py\n    \u251c\u2500\u2500 manage.py\n    \u2514\u2500\u2500 tutorial\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 asgi.py\n        \u251c\u2500\u2500 settings.py\n        \u251c\u2500\u2500 urls.py\n        \u2514\u2500\u2500 wsgi.py\n</code></pre> <p>Now sync your database for the first time:</p> <pre><code>python manage.py makemigrations # create migrations for blog\npython manage.py migrate\n</code></pre> <p>We'll also create an initial user named <code>admin</code> with a password. We'll authenticate as that user later in our example.</p> <pre><code>    python manage.py createsuperuser --username admin --email admin@example.com\n</code></pre> <p>Now lets add <code>blog</code> app and <code>vectordb</code> to the <code>INSTALLED_APPS</code> in <code>tutorial/settings.py</code></p> tutorial/settings.py<pre><code># settings.py\nINSTALLED_APPS = [\n'django.contrib.admin',\n'django.contrib.auth',\n'django.contrib.contenttypes',\n'django.contrib.sessions',\n'django.contrib.messages',\n'django.contrib.staticfiles',\n\"blog\", # add blog to here\n\"vectordb\", # add vectordb to here. The order is not important though\n]\n</code></pre> <p>Next, let's add a <code>POST</code> model to our blog app by modifying <code>blog/models.py</code>, which will enable us to save our posts. Additionally, we will include the <code>get_vectordb_text</code> method to specify the text we want to search by in <code>vectordb</code>. We will also implement the <code>get_vectordb_metadata</code> method to incorporate specific fields we wish to filter by. If we don't create our custom <code>get_vectordb_metadata</code>, <code>vectordb</code> will serialize all the fields into metadata, which could be suboptimal as we might not be interested in some of the fields added. Therefore, it is recommended to implement our own <code>get_vectordb_metadata</code> that contains only the fields we want to filter by. These methods will allow <code>vectordb</code> to perform additional functions for us.</p> blog/models.py<pre><code># blog/models.py\nfrom django.db import models\nfrom django.contrib.auth import get_user_model\nUser = get_user_model()\nclass Post(models.Model):\ntitle = models.CharField(max_length=100)\ndescription = models.TextField()\nuser = models.ForeignKey(User, on_delete=models.CASCADE)\ncreated_at = models.DateTimeField(auto_now_add=True)\ndef get_vectordb_text(self):\nreturn self.title + \" \" + self.description\ndef get_vectordb_metadata(self):\nreturn {\n# so we can filter by user id\n\"user_id\": self.user.id,\n# so we can filter by username\n\"username\": self.user.username,\n# so we can filter by created_at_year\n\"created_at_year\": self.created_at.year,\n# so we can filter by created_at_month\n\"created_at_month\": self.created_at.month,\n}\ndef __str__(self):\nreturn self.title\n</code></pre> <p>Our model has three fields, the <code>title</code>, <code>description</code>, <code>created_at</code>, and a <code>user</code> foreign key. In the metadata we include the <code>user_id</code>, <code>username</code>, <code>created_at_year</code>, and <code>created_at_month</code>. We will use these fields to filter our results later.</p> <p>Now lets make migrations and make tables for the <code>blog</code> app and the <code>vectordb</code> app.</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> <p>Run the development server now</p> <pre><code>./manage.py runserver\n</code></pre>"},{"location":"tutorial/quickstart/#adding-sample-blogs","title":"Adding Sample Blogs","text":"<p>Lets add the Post model to the admins panel. Edit the <code>blog/admin.py</code></p> blog/admin.py<pre><code># blog/admin.py\nfrom django.contrib import admin\nfrom .models import Post\nadmin.site.register(Post)\n</code></pre> <p>Now we can visit http://127.0.0.1:8000/admin/blog/post/ and add a few Posts. Go ahead and add something</p>"},{"location":"tutorial/quickstart/#configuring-vector-search","title":"Configuring Vector Search","text":"<p>First, let's synchronize all posts with the vector database. To do this, simply run the following command:</p> <pre><code>python manage.py vectordb_sync &lt;app_name&gt; &lt;model_name&gt;\n</code></pre> <p>For this example we run:</p> <pre><code>python manage.py vectordb_sync blog Post\n</code></pre> <p>Lastly, let's make sure that the Post model remains synchronized with the vector database, so that any changes, such as creating, deleting, or updating posts, are automatically registered by <code>vectordb</code>. To do this, we'll create a <code>signals.py</code> file in the blog directory and input the following code:</p> blog/signals.py<pre><code>from vectordb.shortcuts import autosync_model_to_vectordb\nfrom .models import Post\nautosync_model_to_vectordb(Post)\n</code></pre> <p>The above code is equivalent to doing the following manually:</p> blog/signals.py<pre><code># blog/signals.py\nfrom django.db.models.signals import post_save, post_delete\nfrom vectordb.sync_signals import (\nsync_vectordb_on_create_update,\nsync_vectordb_on_delete,\n)\nfrom .models import Post\npost_save.connect(\nsync_vectordb_on_create_update,\nsender=Post,\ndispatch_uid=\"update_vector_index_super_unique_id\",\n)\npost_delete.connect(\nsync_vectordb_on_delete,\nsender=Post,\ndispatch_uid=\"delete_vector_index_super_unique_id\",\n)\n</code></pre> <p>Then import the signals in your <code>apps.py</code></p> blog/apps.py<pre><code># blog/apps.py\nfrom django.apps import AppConfig\nclass BlogConfig(AppConfig):\ndefault_auto_field = \"django.db.models.BigAutoField\"\nname = \"blog\"\n# add ready method if not defined\ndef ready(self):\n# import signals\nimport blog.signals\n</code></pre> <p>Now we can run the development server again</p> <pre><code>./manage.py shell\n</code></pre> <pre><code>from blog.models import Post\nfrom django.contrib.auth import get_user_model\nUser = get_user_model()\nuser = User.objects.first()\npost = Post(title=\"A Culinary Journey\", description=\"A journey through France\", user=user)\npost.save()\n</code></pre> <p>Now run the app</p> <pre><code>./manage.py runserver\n</code></pre> <p>Now, when you visit the Django Vector Database Admin Panel at http://127.0.0.1:8000/admin/vectordb/vector/, you'll notice that the new post has been automatically added to the vector database. Similarly, if you try to delete a post, it will be automatically removed from the vector database as well. All these features come built-in with <code>vectordb</code>, ensuring a seamless and efficient experience.</p>"},{"location":"tutorial/quickstart/#fast-vector-search","title":"Fast Vector Search","text":"<p>To perform a search, simply invoke the <code>vectordb.search()</code> method:</p> <pre><code>from vectordb import vectordb\nresults = vectordb.search(\"A Culinary Journey\", k=10) # k represents the maximum number of results desired.\n# get the search time in seconds\nprint(results.search_time) # only available if search is the last method called\n</code></pre> <p>Note that the search method returns a QuerySet with results ordered by the best match. The QuerySet will also have the search_time in seconds which only available when search is the last method called on the QuerySet. Each result item will contain the following fields: <code>id</code>, <code>content_object</code>, <code>object_id</code>, <code>content_type</code>, <code>text</code>, <code>embedding</code>, an annotated <code>score</code>, and a <code>vector</code> property that returns the <code>np.ndarray</code> representation of the embedding field, which is in <code>bytes</code>. As the search provides a <code>QuerySet</code>, you can selectively display the fields you want like this:</p> <pre><code>from vectordb import vectordb\nresults = vectordb.search(\"A Culinary Journey\", k=10).only('text', 'content_object')\n</code></pre> <p>If <code>k</code> is not specified, the default value is 10.</p> <p>Search doesn't only work for <code>text</code> you can also search for model instances:</p> <pre><code>post1 = Post.objects.get(id=1)\n# Limit the search scope to a user with an id of 1\nresults = vectordb.search(post1, k=10)\n</code></pre> <p>This is also a way to get related posts to <code>post1</code>. Thus, you can use <code>vectordb</code> for recommendations as well.</p> <p>Note: Seaching by model instances will automatically scope the results to instances of that type. For example, if you search by <code>post1</code> you will only get results that are instances of <code>Post</code>.</p>"},{"location":"tutorial/quickstart/#filtering","title":"Filtering","text":"<p>You can apply filters on <code>text</code> or <code>metadata</code> using the full capabilities of Django QuerySet filtering:</p> <pre><code># Limit the search scope to a user with an id of 1\nresults = vectordb.filter(metadata__user_id=1).search(\"A Culinary Journey\", k=10)\n# Scope the results to text which contains France, belonging to user with id 1 and created in 2023\nvectordb.filter(text__icontains=\"France\", metadata__user_id=1, metadata__create_at_year=2023).search(\"A Culinary Journey\", k=10)\n</code></pre> <p>We can also use model instances instead of text:</p> <pre><code>post1 = Post.objects.get(id=1)\n# Limit the search scope to a user with an id of 1\nresults = vectordb.filter(metadata__user_id=1).search(post1, k=10)\n# Scope the results to text which contains France, belonging to user with id 1 and created in 2023\nvectordb.filter(text__icontains=\"France\", metadata__user_id=1, metadata__create_at_year=2023).search(post1, k=10)\n</code></pre> <p>For more information on filtering, refer to the Django documentation on querying the <code>JSONField</code>.</p>"},{"location":"tutorial/quickstart/#manually-adding-items-to-the-vector-database","title":"Manually Adding Items to the Vector Database","text":"<p>VectorDB also provides a way to manually add items to it. This is useful if you want to add items to the database that are not in the database yet.</p> <p>VectorDB provides two utility methods for adding items to the database: <code>vectordb.add_instance</code> or <code>vectordb.add_text</code>. Note that for adding the instance, you need to provide the <code>get_vectordb_text</code> and an optional <code>get_vectordb_metadata</code> methods.</p>"},{"location":"tutorial/quickstart/#1-adding-model-instances","title":"1. Adding Model Instances","text":"<pre><code>post1 = models.create(title=\"post1\", description=\"post1 description\", user=user1) # provide valid user\n# add to vector database\nvectordb.add_instance(post1)\n</code></pre>"},{"location":"tutorial/quickstart/#2-adding-text-to-the-model","title":"2. Adding Text to the Model","text":"<p>To add text to the database, you can use <code>vectordb.add_text()</code>:</p> <pre><code>vectordb.add_text(text=\"Hello text\", id=3, metadata={\"user_id\": 1})\n</code></pre> <p>The <code>text</code> and <code>id</code> are required. Additionally, the <code>id</code> must be unique, or an error will occur. <code>metadata</code> can be <code>None</code> or any valid JSON.</p>"},{"location":"tutorial/quickstart/#settings","title":"Settings","text":"<p>You can customize <code>vectordb</code> by providing your settings in the <code>settings.py</code> file of your project. The following settings are available:</p> settings.py<pre><code># settings.py\nDJANGO_VECTOR_DB = {\n\"DEFAULT_EMBEDDING_CLASS\": ..., # Default: \"vectordb.embedding_functions.SentenceTransformerEncoder\",\n\"DEFAULT_EMBEDDING_MODEL\": ..., # Default: \"all-MiniLM-L6-v2\",\n# Can be \"cosine\" or \"l2\"\n\"DEFAULT_EMBEDDING_SPACE\": ..., # Default \"l2\"\n\"DEFAULT_EMBEDDING_DIMENSION\": ..., # Default is 384 for \"all-MiniLM-L6-v2\"\n\"DEFAULT_MAX_N_RESULTS\": 10, # Number of results to return from search maximum is default is 10\n\"DEFAULT_MIN_SCORE\": 0.0, # Minimum score to return from search default is 0.0\n\"DEFAULT_MAX_BRUTEFORCE_N\": 10_000, # Maximum number of items to search using brute force default is 10_000. If the number of items is greater than this number, the search will be done using the HNSW index.\n}\n</code></pre>"},{"location":"tutorial/quickstart/#summary","title":"Summary","text":"<p>Great! That was a quickstart to <code>django-vectordb</code>. We've created a blogging site and added extremely fast vector search to it. If you want to get a more in depth understanding of <code>vectordb</code> head on over to the tutorial.</p>"}]}